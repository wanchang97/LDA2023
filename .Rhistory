alpha = seq(1/k,1/k,length=k),
S = 20,n=100,r=100,h="nrd0",...){
# Computing the density of the mixture of normals
k <- length(mu)
minx <- min(mu-3*sigma)
maxx <- max(mu+3*sigma)
y <- seq(minx,maxx,length=r)
fy <- 0*y
Salpha <- sum(alpha)
for (i in 1:k){
p <- alpha[i]/Salpha
fy <- fy + p*dnorm(y,mu[i],sigma[i])
}
hfy <- matrix(0,S,r)
for (i in 1:S){
x <- sim.mixt(n=n,k=k,mu=mu,sigma=sigma,alpha=alpha)
dx <- density(x,bw=h,from=minx,to= maxx,n=r,...)
hfy[i,] <- dx$y
}
m_hf <- apply(hfy,2,mean)
sd_hf <- apply(hfy,2,sd)
delta <- y[2]-y[1]
ECM <- sd_hf^2+(fy-m_hf)^2
MISE <- sum(ECM)*delta
#[MISE,naux] <- simpson(ECM,minx,maxx)
plot(y,fy,ty="l",  lwd=3, ...)
title(main=paste("MISE= ",MISE,sep=""))
lines(y,m_hf,col=2)
L <- m_hf-1.96*sd_hf
U <- m_hf+1.96*sd_hf
lines(y,L,col=3,lty=2)
lines(y,U,col=3,lty=2)
return(list(y=y,fy=fy,m_hf=m_hf,sd_hf=sd_hf,MISE=MISE))
}
# Defining the function variability_plot_kernel
variability_plot_kernel <- function(k=1,
mu = seq(-2*(k-1),2*(k-1),length=k),
sigma=seq(1,1,length=k),
alpha = seq(1/k,1/k,length=k),
S = 20,n=100,r=100,h="nrd0",...){
# Computing the density of the mixture of normals
k <- length(mu)
minx <- min(mu-3*sigma)
maxx <- max(mu+3*sigma)
y <- seq(minx,maxx,length=r)
fy <- 0*y
Salpha <- sum(alpha)
for (i in 1:k){
p <- alpha[i]/Salpha
fy <- fy + p*dnorm(y,mu[i],sigma[i])
}
hfy <- matrix(0,S,r)
for (i in 1:S){
x <- sim.mixt(n=n,k=k,mu=mu,sigma=sigma,alpha=alpha)
dx <- density(x,bw=h,from=minx,to= maxx,n=r,...)
hfy[i,] <- dx$y
}
m_hf <- apply(hfy,2,mean)
sd_hf <- apply(hfy,2,sd)
delta <- y[2]-y[1]
ECM <- sd_hf^2+(fy-m_hf)^2
MISE <- sum(ECM)*delta
#[MISE,naux] <- simpson(ECM,minx,maxx)
plot(y,fy,ty="l",  lwd=3, ...)
title(main=paste("MISE= ",MISE,sep=""))
lines(y,m_hf,col=2)
L <- m_hf-1.96*sd_hf
U <- m_hf+1.96*sd_hf
lines(y,L,col=3,lty=2)
lines(y,U,col=3,lty=2)
return(list(y=y,fy=fy,m_hf=m_hf,sd_hf=sd_hf,MISE=MISE))
}
S <- 30
n <- 100
mu <- c(0,3/2)
sigma <- c(1,1/3)
alpha <- c(3/4,1/4)
r <- 100
op<-par(mfrow=c(1,3))
vpk.1 <- variability_plot_kerenl(mu=mu, sigma=sigma, alpha=alpha,
S=S, n=n, r=r, h="nrd0", adjust=.4,ylim=c(0,0.55))
# Defining the function variability_plot_kernel
variability_plot_kernel <- function(k=1,
mu = seq(-2*(k-1),2*(k-1),length=k),
sigma=seq(1,1,length=k),
alpha = seq(1/k,1/k,length=k),
S = 20,n=100,r=100,h="nrd0",...){
# Computing the density of the mixture of normals
k <- length(mu)
minx <- min(mu-3*sigma)
maxx <- max(mu+3*sigma)
y <- seq(minx,maxx,length=r)
fy <- 0*y
Salpha <- sum(alpha)
for (i in 1:k){
p <- alpha[i]/Salpha
fy <- fy + p*dnorm(y,mu[i],sigma[i])
}
hfy <- matrix(0,S,r)
for (i in 1:S){
x <- sim.mixt(n=n,k=k,mu=mu,sigma=sigma,alpha=alpha)
dx <- density(x,bw=h,from=minx,to= maxx,n=r,...)
hfy[i,] <- dx$y
}
m_hf <- apply(hfy,2,mean)
sd_hf <- apply(hfy,2,sd)
delta <- y[2]-y[1]
ECM <- sd_hf^2+(fy-m_hf)^2
MISE <- sum(ECM)*delta
#[MISE,naux] <- simpson(ECM,minx,maxx)
plot(y,fy,ty="l",  lwd=3, ...)
title(main=paste("MISE= ",MISE,sep=""))
lines(y,m_hf,col=2)
L <- m_hf-1.96*sd_hf
U <- m_hf+1.96*sd_hf
lines(y,L,col=3,lty=2)
lines(y,U,col=3,lty=2)
return(list(y=y,fy=fy,m_hf=m_hf,sd_hf=sd_hf,MISE=MISE))
}
S <- 30
n <- 100
mu <- c(0,3/2)
sigma <- c(1,1/3)
alpha <- c(3/4,1/4)
r <- 100
op<-par(mfrow=c(1,3))
vpk.1 <- variability_plot_kerenl(mu=mu, sigma=sigma, alpha=alpha,
S=S, n=n, r=r, h="nrd0", adjust=.4,ylim=c(0,0.55))
S <- 30
n <- 100
mu <- c(0,3/2)
sigma <- c(1,1/3)
alpha <- c(3/4,1/4)
r <- 100
op<-par(mfrow=c(1,3))
vpk.1 <- variability_plot_kernel(mu=mu, sigma=sigma, alpha=alpha,
S=S, n=n, r=r, h="nrd0", adjust=.4,ylim=c(0,0.55))
vpk.2 <- variability_plot_kernel(mu=mu, sigma=sigma, alpha=alpha,
S=S, n=n, r=r, h="nrd0", adjust=.75,ylim=c(0,0.55))
vpk.3 <- variability_plot_kernel(mu=mu, sigma=sigma, alpha=alpha,
S=S, n=n, r=r, h="nrd0", adjust=1.5,ylim=c(0,0.55))
# Defining the function variability_plot_kernel
#
variability_plot_kerenl <- function(k=1,
mu=seq(-2*(k-1),2*(k-1),length=k),
sigma=seq(1,1,length=k),
alpha=seq(1/k,1/k,length=k),
S=20, n=100, r=100,
h="nrd0", ...){
# computing the density of thr mixture of normals
k <- length(mu)
minx <- min(mu-3*sigma)
maxx <- max(mu+3*sigma)
y <- seq(minx,maxx,length=r)
fy <- 0*y
Salpha<-sum(alpha)
for(i in 1:k){
p<-alpha[i]/Salpha
#    fy <- fy + p*exp(-.5*((y-mu[i])/sigma[i])^2)/(sqrt(2*pi)*sigma[i])
fy <- fy + p*dnorm(y,mu[i],sigma[i])
}
hfy <- matrix(0,S,r)
for (i in 1:S){
x <- sim.mixt(n=n,k=k,mu=mu,sigma=sigma,alpha=alpha)
dx <- density(x, bw=h, from=minx, to=maxx, n=r, ...)
hfy[i,] <- dx$y
}
m_hf <- apply(hfy,2,mean)
sd_hf <- apply(hfy,2,sd)
delta <- y[2]-y[1]
ECM <- sd_hf^2+(fy-m_hf)^2
MISE <- sum(ECM)*delta
#[MISE,naux] <- simpson(ECM,minx,maxx)
plot(y,fy,ty="l",  lwd=3, ...)
title(main=paste("MISE= ",MISE,sep=""))
lines(y,m_hf,col=2)
L <- m_hf-1.96*sd_hf
U <- m_hf+1.96*sd_hf
lines(y,L,col=3,lty=2)
lines(y,U,col=3,lty=2)
return(list(y=y,fy=fy,m_hf=m_hf,sd_hf=sd_hf,MISE=MISE))
}
S <- 30
n <- 100
mu <- c(0,3/2)
sigma <- c(1,1/3)
alpha <- c(3/4,1/4)
r <- 100
op<-par(mfrow=c(1,3))
vpk.1 <- variability_plot_kernel(mu=mu, sigma=sigma, alpha=alpha,
S=S, n=n, r=r, h="nrd0", adjust=.4,ylim=c(0,0.55))
vpk.2 <- variability_plot_kernel(mu=mu, sigma=sigma, alpha=alpha,
S=S, n=n, r=r, h="nrd0", adjust=.75,ylim=c(0,0.55))
vpk.3 <- variability_plot_kernel(mu=mu, sigma=sigma, alpha=alpha,
S=S, n=n, r=r, h="nrd0", adjust=1.5,ylim=c(0,0.55))
# Defining the function variability_plot_kernel
#
variability_plot_kernel <- function(k=1,
mu=seq(-2*(k-1),2*(k-1),length=k),
sigma=seq(1,1,length=k),
alpha=seq(1/k,1/k,length=k),
S=20, n=100, r=100,
h="nrd0", ...){
# computing the density of thr mixture of normals
k <- length(mu)
minx <- min(mu-3*sigma)
maxx <- max(mu+3*sigma)
y <- seq(minx,maxx,length=r)
fy <- 0*y
Salpha<-sum(alpha)
for(i in 1:k){
p<-alpha[i]/Salpha
#    fy <- fy + p*exp(-.5*((y-mu[i])/sigma[i])^2)/(sqrt(2*pi)*sigma[i])
fy <- fy + p*dnorm(y,mu[i],sigma[i])
}
hfy <- matrix(0,S,r)
for (i in 1:S){
x <- sim.mixt(n=n,k=k,mu=mu,sigma=sigma,alpha=alpha)
dx <- density(x, bw=h, from=minx, to=maxx, n=r, ...)
hfy[i,] <- dx$y
}
m_hf <- apply(hfy,2,mean)
sd_hf <- apply(hfy,2,sd)
delta <- y[2]-y[1]
ECM <- sd_hf^2+(fy-m_hf)^2
MISE <- sum(ECM)*delta
#[MISE,naux] <- simpson(ECM,minx,maxx)
plot(y,fy,ty="l",  lwd=3, ...)
title(main=paste("MISE= ",MISE,sep=""))
lines(y,m_hf,col=2)
L <- m_hf-1.96*sd_hf
U <- m_hf+1.96*sd_hf
lines(y,L,col=3,lty=2)
lines(y,U,col=3,lty=2)
return(list(y=y,fy=fy,m_hf=m_hf,sd_hf=sd_hf,MISE=MISE))
}
S <- 30
n <- 100
mu <- c(0,3/2)
sigma <- c(1,1/3)
alpha <- c(3/4,1/4)
r <- 100
op<-par(mfrow=c(1,3))
vpk.1 <- variability_plot_kernel(mu=mu, sigma=sigma, alpha=alpha,
S=S, n=n, r=r, h="nrd0", adjust=.4,ylim=c(0,0.55))
vpk.2 <- variability_plot_kernel(mu=mu, sigma=sigma, alpha=alpha,
S=S, n=n, r=r, h="nrd0", adjust=.75,ylim=c(0,0.55))
vpk.3 <- variability_plot_kernel(mu=mu, sigma=sigma, alpha=alpha,
S=S, n=n, r=r, h="nrd0", adjust=1.5,ylim=c(0,0.55))
library(sm)
op <- par(mfrow=c(1,2))
sm.density(cbind(Boston$lstat,Boston$rm),h=c(1.5,.15),phi=30,theta=60,col=5,
xlab="lstat",ylab="rm",zlab="density")
sm.density(cbind(Boston$lstat,Boston$rm),h=c(1.5,.15),display="slice",
xlab="lstat",ylab="rm")
sm.density(cbind(Boston$lstat,Boston$rm),h=c(1.5,.15),display="slice",add=T,col=2,props=c(90))
points(Boston$lstat,Boston$rm,pch=19,cex=.3)
library(rgl)
install.packages("rgl")
library(rgl)
plot(Boston$lstat,Boston$rm)
out <- sm.density(cbind(Boston$lstat,Boston$rm),
h=c(1.5,.15),display="none")
persp3d(x=out$eval.points[,1],
y=out$eval.points[,2],
z=out$estimate,col="lightblue")
op <- par(mfrow=c(1,2))
sm.density(cbind(Boston$lstat,Boston$rm),h=c(1.5,.15),phi=30,theta=60,col=5,
xlab="lstat",ylab="rm",zlab="density")
sm.density(cbind(Boston$lstat,Boston$rm),h=c(1.5,.15),display="slice",
xlab="lstat",ylab="rm")
sm.density(cbind(Boston$lstat,Boston$rm),h=c(1.5,.15),display="slice",add=T,col=2,props=c(90))
points(Boston$lstat,Boston$rm,pch=19,cex=.3)
library(rstan)
# Setup RStan to run in parallel on multiple processors
options(mc.cores = parallel::detectCores())
# Generative normal model
N <- 10
mu <- 1.5
sigma <- 0.1
Y <- rnorm(N, mu, sigma)
# Data
data_list <- list(
N = N,
Y = Y)
# Compile and run the MCMC on the Stan program
set.seed(1234)
fit <- stan("stan_models/simple.stan", iter = 2000, chains = 4,
data = data_list)
Sys.getenv("BINPREF")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"',con="~/.Renviron")
Sys.which("make")
install.packages("rstan",type="source")
example(stan_model, package = "rstan", run.dontrun = TRUE)
Sys.getenv("BINPREF")
[1] ""
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
Sys.which("make")
writeLines('PATH="${RTOOLS42_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars.win")
if (!file.exists(M)) file.create(M)
cat("\n CXX14FLAGS += -mtune=native -O3 -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2",
file = M, sep = "\n", append = FALSE)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
Sys.setenv(DOWNLOAD_STATIC_LIBV8 = 1) # only necessary for Linux without the nodejs library / headers
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
Sys.which("make")
## "C:\\rtools40\\usr\\bin\\make.exe"
install.packages("jsonlite", type = "source")
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars.win")
if (!file.exists(M)) file.create(M)
cat("\n CXX14FLAGS += -mtune=native -O3 -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2",
file = M, sep = "\n", append = FALSE)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
Sys.setenv(DOWNLOAD_STATIC_LIBV8 = 1) # only necessary for Linux without the nodejs library / headers
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
Sys.setenv(DOWNLOAD_STATIC_LIBV8 = 1) # only necessary for Linux without the nodejs library / headers
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
# run the next line if you already have rstan installed
# remove.packages(c("StanHeaders", "rstan"))
install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
Sys.which("make")
example(stan_model, package = "rstan", run.dontrun = TRUE)
Sys.getenv("BINPREF")
[1] ""
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
## "C:\\rtools40\\usr\\bin\\make.exe"
install.packages("jsonlite", type = "source")
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars.win")
if (!file.exists(M)) file.create(M)
cat("\n CXX14FLAGS += -mtune=native -O3 -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2",
file = M, sep = "\n", append = FALSE)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
Sys.setenv(DOWNLOAD_STATIC_LIBV8 = 1) # only necessary for Linux without the nodejs library / headers
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
setwd("C:/UPC Master/LongitudinalDataAnalysis/LDA-lab/04 - 100323 - Advanced Linear Mixed Models-20230313")
library(nlme)
library(lme4)
library(lattice)
library(ggplot2)
# Load data
data("sleepstudy")
#First brief look data
head(sleepstudy)
summary(sleepstudy)
#Group data
SleepGrouped<-groupedData(Reaction~Days|Subject,sleepstudy,labels=list(y="Average reaction time"),units=list(y="(milliseconds)"))
plot(SleepGrouped)
setwd("C:/Users/Asus/Desktop/MESIO - LDA/2022-2023/05_LMM2")
pdf("Spaghetti.pdf",width=12)
setwd("C:/UPC Master/LongitudinalDataAnalysis/LDA-lab/04 - 100323 - Advanced Linear Mixed Models-20230313")
library(nlme)
library(lme4)
library(lattice)
library(ggplot2)
# Load data
data("sleepstudy")
#First brief look data
head(sleepstudy)
summary(sleepstudy)
#Group data
SleepGrouped<-groupedData(Reaction~Days|Subject,sleepstudy,labels=list(y="Average reaction time"),units=list(y="(milliseconds)"))
plot(SleepGrouped)
#setwd("C:/Users/Asus/Desktop/MESIO - LDA/2022-2023/05_LMM2")
pdf("Spaghetti.pdf",width=12)
#Spaghetti plot
xyplot(Reaction ~ Days, groups = Subject,
data = sleepstudy,
type = "l" ,xlab="Days from Study Start",ylab="Average reaction time")
dev.off()
#Individual plots
pdf("Individual.pdf",width=12)
plot(SleepGrouped)
dev.off()
#First model, no random effects
model.noref<- lmer(Reaction ~ Days,data=sleepstudy)
setwd("C:/UPC Master/LongitudinalDataAnalysis/github/LDA2023")
knitr::opts_chunk$set(echo = TRUE)
install.packages("readxl")
library(readxl)
trenal <- read_excel("Trenal.XLS")
summary(trenal)
trenal= trenal[,-18]
summary(trenal)
dim(trenal)
trenal.long = trenal[,13:20]
summary(trenal.long)
dim(trenal.long)
#install.packages("magrittr") # package installations are only needed the first time you use it
#install.packages("dplyr")    # alternative installation of the %>%
library(magrittr) # needs to be run every time you start R and want to use %>%
library(dplyr)
data <- trenal.long %>%
relocate(id) %>%
relocate(j,.after=id)%>%
relocate(time,.after = j)%>%
relocate(respons,.after=time)
trenal.long$id = as.factor(trenal.long$id)
trenal.long$j = as.factor(trenal.long$j)
trenal.long$male = as.factor(trenal.long$male)
trenal.long$cardio = as.factor(trenal.long$cardio)
trenal.long$reject = as.factor(trenal.long$reject)
summary(trenal.long)
length(unique(trenal.long$id))
# Plot the raw data
plot(trenal.long$time,trenal.long$respons)
summary(data.selected)
summary(data)
# Plot the raw data
xyplot(respons ~ time, groups = id, data=data, type="l",xlab="Time (year)",ylab="HC level " )
View(data)
# Individual plots
plot(data[,-2])
# Individual plots
plot(data[,c(1,3,4)])
# Individual plots
ggplot(data.selected,aes(x=time,y=respons,group=id,color=id))+geom_point()+ geom_line
#Select a sample of data to plot
set.seed(1)
selected <- sample(1:length(unique(trenal.long$id)),30,replace=T) # random samples and permutations
#selected.vector = as.vector(selected)
data.selected = data[(data$id %in% c(selected)), ]
# Individual plots
ggplot(data.selected,aes(x=time,y=respons,group=id,color=id))+geom_point()+ geom_line
# Individual plots
ggplot(data.selected,aes(x=time,y=respons,group=id,color=id))+geom_point()+ geom_line()
# Individual plots
plot(data.selected)
?plot
plot(trenal.wide)
trenal.wide = trenal[,1:17]
summary(trenal.wide)
plot(trenal.wide)
plot(trenal.wide[1:30,])
plot(trenal.wide[1:30,])
ggplot(data.selected,aes(x=time,y=respons,group=id,color=id))+geom_point()+ geom_line()
# Plot individual data by sex
ggplot(data.selected,aes(x=time,y= respons,group=id, color=sex))+geom_point()+geom_line()
# Plot individual data by sex
ggplot(data.selected,aes(x=time,y= respons,group=id, color=male))+geom_point()+geom_line()
# Plot mean of male and mean of female
library(dplyr)
MEAN <- data.selected %>%
group_by(male,age,cardio,reject) %>%
summarise(respons = mean(respons))
MEAN
ggplot(data.selected,aes(x=age,y=respons,color=male)) + geom_line(data=MEAN)
p <- ggplot(data=data.selected,aex(x=time,y=respons,group=id))
p <- ggplot(data=data.selected,aes(x=time,y=respons,group=id))
p <- p + geom_line(col="grey")+stat_summary(aes(group=1),geom="line",fun=mena,linewidth=2)
p <- ggplot(data=data.selected,aes(x=time,y=respons,group=id))
p <- p + geom_line(col="grey")+stat_summary(aes(group=1),geom="line",fun=mean,linewidth=2)
p + facet_grid(~sex)
p <- ggplot(data=data.selected,aes(x=time,y=respons,group=id))
p <- p + geom_line(col="grey")+stat_summary(aes(group=1),geom="line",fun=mean,linewidth=2)
p + facet_grid(~male)
# Spaghetti Ggplot separated by cardio
p <- ggplot(data=data.selected,aes(x=time,y=respons,group=id))
p <- p + geom_line(col="grey")+stat_summary(aes(group=1),geom="line",fun=mean,linewidth=2)
p + facet_grid(~cardio)
# Spaghetti Ggplot separated by reject =1
p <- ggplot(data=data.selected,aes(x=time,y=respons,group=id))
p <- p + geom_line(col="grey")+stat_summary(aes(group=1),geom="line",fun=mean,linewidth=2)
p + facet_grid(~reject)
# BoxPlot
ggplot(data.selected,aex(x=as.factor(age),y=respons))+ geom_boxplot(position=position_dodge(1))
# BoxPlot
ggplot(data.selected,aes(x=as.factor(age),y=respons))+ geom_boxplot(position=position_dodge(1))
# BoxPlot
ggplot(data.selected,aes(x=as.factor(time),y=respons))+ geom_boxplot(position=position_dodge(1))
# Box plot by sex
ggplot(data.selected,aes(x=as.factor(time),y=respons,fill=as.factor(male)))+
geom_boxplot(position=position_dodge(1))
# Box plot by cardio
ggplot(data.selected,aes(x=as.factor(time),y=respons,fill=as.factor(cardio)))+
geom_boxplot(position=position_dodge(1))
# Box plot by reject
ggplot(data.selected,aes(x=as.factor(time),y=respons,fill=as.factor(reject)))+
geom_boxplot(position=position_dodge(1))
# Plot the raw data
install.packages("thePackage")
require(thePackage)
# Plot the raw data
#install.packages("thePackage")
require(thePackage)
xyplot(respons ~ time, groups = id, data=data, type="l",xlab="Time (year)",ylab="HC level " )
# Plot the raw data
#install.packages("thePackage")
require(tigerstats)
xyplot(respons ~ time, groups = id, data=data, type="l",xlab="Time (year)",ylab="HC level " )
# Plot the raw data
install.packages("tigerstats")
require(tigerstats)
xyplot(respons ~ time, groups = id, data=data, type="l",xlab="Time (year)",ylab="HC level " )
